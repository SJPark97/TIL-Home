### Javascript를 배워야 하는 이유
- web 기술의 기반이 되는 언어
- web이라는 공간에서 채팅, 게임 등 다양한 동작을 할 수 있게 된 기반
- web 조작을 넘어서 서버 프로그래밍, 모바일 서비스, 컴퓨터 응용 프로그래밍, 블록체인, 게임 개발 등 다양한 분야에서 활용이 가능한 언어
- 개발자라면 필수적으로 가지고 있어야하는 언어 (가장 큰 인기를 얻고 있는 언어)
- 특히 크롬의 V8의 경우 Javascript를 번역하는 속도가 매우 빠름
  - node.js, react.js, electrion 등의 내부 엔진으로 사용
  - 그 결과, back-end, mobile, desktop app등을 모두 Javascript로 개발이 가능해짐

### Javascript 시작하기
- Web browser로 실행하기
  - HTML 파일에 포함시키기
  - 외부 Javascript 파일 사용하기
  - Web browser에서 바로 입력하기
- Node.js로 실행하기

1. Web browser로 실행하기
- HTML 파일에 직접 script태그에 Javascript를 작성 후 브라우저로 파일을 열면 콘솔에서 확인 가능(body태그 안에서 작성)
- js파일을 HTML 파일에서 열기(body태그 밑에서 작성)
- 브라우저 콘솔에서 바로 코드 작성하기
- 웹 브라우저에서 바로 사용할 수 있는 Javascript 언어를 Vanilla Javascript라고 부름

2. Node.js로 실행하기
- node 파일명.js를 터미널에 작성하면 실행됨

### Javascript 코드 작성법
- 세미콜론
  - 자바스크립트는 세미콜론을 선택적으로 사용 가능
  - 세미콜론이 없으면 ASI에 의해 자동으로 세미콜론이 삽입됨
    - ASI(Automatic Semicolon Insertion, 자동 세미콜론 삽입 규칙)
  - 본 수업에서는 자바스크립트의 문법 및 개념적 측면에 집중하기 위해 세미콜론을 사용하지 않고 진행
```javascript
// 세미콜론 예시
console.log('hello');
console.log('hello')
// 똑같이 동작함
```
- 들여쓰기와 코드 블럭
  - python은 4칸 들여쓰기를 사용했으나, Javascript는 2칸 들여쓰기를 사용
  - 블럭은 if, for, 함수에서 중괄효 { } 내부를 말함
    - python은 들여쓰기를 이용해서 코드 블럭을 구분
    - Javascript는 중괄호 { }를 사용해 코드 블럭을 구분

- 코드 스타일 가이드
  - 코딩 스타일의 핵심은 합의된 원칙과 일관성
  - 코드의 품질에 직결되는 중요한 요소
    - 코드의 가독성, 유지보수 또는 팀원과의 커뮤니케이션 등 개발 과정 전체에 영향을 끼침
  - python에도 PEP8이라는 코드 스타일 가이드가 있었듯, Javascript에도 코드 스타일 가이드 존재
  - 다만 Javascript는 여러 코드 스타일 가이드가 회사마다 존재하는데, 수업에서는 Airbnb Style Guide를 기반으로 사용할 것

- 식별자 정의와 특징
  - 식별자는 변수를 구분할 수 있는 변수명을 말함
  - 식별자는 반드시 문자, 달러 또는 밑줄로 시작
  - 대소문자를 구분하며, 클래스명 외에는 모드 소문자로 시작
  - 예약어 사용 불가능
    - 예약어 예시 : for, if, function 등
  - 카멜 케이스(camelCase, lower-camel-case)
    - 변수, 객체, 함수에 사용
  - 파스칼 케이스(PascalCase, upper-camel-case)
    - 클래스, 생성자에 사용
  - 대문자 스네이크 케이스(SNAKE_CASE)
    - 상수에 사용
    - 상수 : 개발자의 의도와 상관없이 변경될 가능성이 없는 값을 의미

- 변수 선언 키워드
  - python과는 다르게 Javascript는 변수를 선언하는 키워드가 있음
    - let : 블록 스코프 지역 변수를 선언 (재할당 가능&재선언 불가능)(추가로 동시에 값을 초기화)
    - const : 블록 스코프 읽기 전용 상수를 선언 (재할당&재선언 불가능, 초기값을 반드시 설정해야 함)(추가로 동시에 값을 초기화)
    - var : 변수를 선언 (재할당&재선언 가능 호이스팅 되는 특성으로 인해 예기치 못한 문제 발생 가능 가능하면 사용하지 않는 것을 추천)(추가로 동시에 값을 초기화)
  - 블록 스코프 : 중괄호 내부를 가리킴 (블록 바깥에서 접근 불가능)
  - 함수 스코프 (function scope)
  - 기본적으로 const 사용을 권장
    - 재할당해야 하는 경우만 let을 사용

- 호이스팅
  - 변수를 선언 이전에 참조할 수 있는 현상
  - var로 선언된 변수는 선언 이전에 참조할 수 있으며, 이러한 현상을 호이스팅이라 함
  - 변수 선언 이전의 위치에서 접근 시 undefined를 반환
  - Javascript에서 변수들은 실제 실해잇에 코드의 최상단으로 끌어올려지게 되며 이러한 이유 때문에 var로 선언된 변수는 선언 시에 undefined로 값이 초기화되는 현상이 일어남
  - 고로 let과 const를 사용하면 이러한 호이스팅현상이 없다.
  - 다만, 아직까지도 많은 기존의 Javascript 코드는 ES6 이전의 문법으로 작성되어 있으므로 호이스팅에 대한 이해가 필요
  - 그러므로 이제부터 작성하는 코드에는 var를 사용하지는 않으나 알고 있어야 한다.

- String
  - 문자열끼리 덧셈 가능
  - 백틱을 사용하면 python f-string에서처럼 ${}로 변수를 문자열 안에서 사용할 수 있다.

- 값이 비어있다
  - null : 값이 없는 것을 의도했을 때
  - undefined : 변수 선언 후 값을 할당하지 않으면 자동으로 할당 됨
  - type를 사용했을 때 null은 null로 나와야하나 object로 나온다 이것은 설계 당시의 버그를 해결하지 못한 것이다.

- 연산자
  - 오른쪽에 있는 피연산자의 평과 결과를 왼쪽 피연산자에 할당하는 연산자
  - 다양한 연산에 대한 단축 연산자 지원
  - c++과 c += 1은 같은 것이나 c += 1처럼 분명한 표현으로 적을 것을 권장한다.
  - 비교 연산자
  - 피연산자들을 비교하교 결과값을 boolean으로 반환하는 연산자
  - 동등 연산자(==)
    - 두 피연산자가 같은 값으로 평과되는지 비교 후 boolean 값을 반환
    - 비교할 때 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다
    - 두 피연산자가 모두 객체일 경우 메모리의 같은 객체를 바라보는지 판별
    - 예상치 못한 결과가 발생할 수 있으므로 특별한 경우를 제외하고 사용하지 않음
  - 일치 연산자(===)
    - 두 피연산자의 값과 타입이 모두 같을 경우 true를 반환
    - 엄격한 비교가 이뤄지며 암묵적 타입 변환이 발생하지 않음
    - python에서 (==)와 같다
  - 논리 연산자
    - 세가지 논리 연산자로 구성
      - and 연산은'&&' 연산자
      - or 연산은 '||' 연산자
      - not 연산은'!' 연산자
    - 단축평가를 지원한다 : 뒤를 보지 않아도 답이 나오면 뒤를 확인하지 않는다.
  - 삼항 연산자
    - 3개의 피연산자를 사용하여 조건에 따라 값을 반환하는 연산자
    - 가장 앞의 조건식이 참이면 :앞의 값이 반환되며, 그 반대일 경우 :뒤의 값이 반환되는 연산자
    - 삼항 연산자의 결과 값이기 때문에 변수에 할당 가능
  
- 조건문
  - 조건문의 종류와 특징
    - if statement : 조건 표현식의 결과값을 boolean 타입으로 변환 후 참/거짓을 판단
      - if, else if, else
        - 조건은 소괄호 안에 작성
        - 실행할 코드는 중괄호 { }안에 작성
        - 블록 스코프 생성
    - switch statement : 조건 표현식의 결과값이 어느 값에 해당하는지 판별
      - 표현식의 결과값을 이용한 조건문
      - 표현식의 결과값과 case문의 오른쪽 값을 비교
      - break 및 default문은 선택적으로 사용 가능
      - break문이 없는 경우 break문을 만나거나 default문을 실행할 때까지 다음 조건문 실행
      - 블록 스코프 생성
```javascript
const name = '홍길동'

switch(name) {
  case '홍길동': {
    console.log('관리자님 환영합니다.')
    break
  }
  case 'manager': {
    console.log('매니저님 환영합니다.')
    break
  }
  default: {
    console.log(`${name}님 환영합니다.`)
  }
}
// break가 없으면 안됌 세가지 케이스 전부 실행되기 때문
```

  - 반복문 종류
    - while
    - for
      - for ([초기문]; [조건문]; [증감문]){//do something}
    - for...in
      - 객체를 순환할때 객체의 key를 반환함(dict)
    - for...of
      - 객체를 순환할때 객체의 value를 반환함(Arry, Set, String)

- 함수
  - 함수 선언식 (function delclaration)
    - function 함수명() {return ---}
    - function add(num1, num2) {return num1 + num2}
  - 함수 표현식 (function expression)
    - 변수 키워드 함수명 = function () {return ---}
    - const sub = function (num1, num2) {return num1 - num2}
    - const sub = function namesub(num1, num2) {return num1 - num2}
    - namesub는 호출하지 못하고 디버깅 용도로 사용됨(크게 활용되지 않음)
  - 인자 작성 시 기본 인자 선언 가능
  - 매개변수보다 인자가 많아도 에러 없이 동작됨
  - spread syntax(...) python에서는 (*)
    - 전개 구문
    - 전개 구문을 사용하면 배열이나 문자열과 같이 반복 가능한 객체를 배열의 경우는 요소, 함수의 경우는 인자로 확장할 수 있음
      1. 배열과의 사용
      2. 함수와의 사용
  - 호이스팅 - 선언식
    - 함수 선언식으로 정의한 함수는 var로 정의한 변수처럼 호이스팅이 발생
    - 즉 함수 호출 이후에 선언해도 동작
  - 호이스팅 - 표현식
    - 반면 함수 표현식으로 선언한 함수는 함수 정의 전에 호출 시 에러 발생
    - 함수 표현식으로 정의된 함수는 변수로 평과되어 변수의 scope 규칙을 따름. 고로 함수 표현식을 사용하는 것을 권장
  - 화살표 함수 (Arrow Function)
    - 함수를 비교적 간결하게 정의할 수 있는 문법
    - function 키워드와 중괄호를 이용한 구문을 짧게 사용하기 위해 탄생
      - function 키워드 생략가능
      - 함수의 매개변수가 하나뿐이라면 `()`도 생략 가능
      - 함수의 내용이 한 줄이라면 `{}`와 `return`도 생략 가능
      - 1단계 const greeting = (name => {return `Hi ${name}`})
      - 최종 함수 const greeting = (name) => `Hi ${name}`
      - 보통 1단계와 최종만 사용함 
    - 화살표 함수는 항상 익명 함수
      - == 함수 표현식에서만 사용가능
  - 즉시 실행 함수
    - 선언과 동시에 실행되는 함수
    - 함수의 선언 끝에 '()'를 추가하여 선언되자마자 실행하는 형태
    - 즉시 실행 함수는 선언과 동시에 실행되기 때문에 같은 함수를 다시 호출할 수 없음
    - 이러한 특징을 살려 초기화 부분에 많이 사용
    - 일회성 함수이므로 익명함수로 사용하는 것이 일반적
  
- 배열 (Array) python에서 list
  - 키와 속성들을 담고 있는 참조 타입의 객체
  - 순서를 보장하는 특징이 있음
  - 주로 대괄호([])를 이용하여 생성하고, 0을 포함한 양의 정수 인덱스로 특정 값에 접근 가능
  - 배열의 길이는 array.length형태로 접근 가능
    - 배열의 마지막 원소는 array.length-1로 접근
  - 배열 메서드 기초
    - reverse : 원본 배열의 요소들의 순서를 반대로 정렬
    - push & pop : 배열의 가장 뒤에 요소를 추가 또는 제거
    - unshift & shift : 배열의 가장 앞에 요소를 추가 또는 제거
    - includes : 배열에 특정 값이 존재하는지 판별 후 참/거짓 반환
    - indexof : 배열에 특정 값이 존재하는지 판별 후 인덱스 반환 (요소가 없을 경우 -1 반환)
    - join : 배열의 모든 요소를 구분자를 이용하여 연결 (구분자 생략 시 쉼표 기준)
  - 배열 메서드 심화
    - forEach : 배열의 각 요소에 대해 콜백 함수를 한 번씩 실행 (반환 값 없음)
      - array.forEach((배열의 요소, 배열 요소의 인덱스, 배열 자체))
    - map : 콜백 함수의 반환 값을 요소로 하는 새로운 배열 반환
      - forEach + return(반환)
    - filter : 콜백 함수의 반환 값이 참인 요소들만 모아서 새로운 배열을 반환
      - map + true(조건)
    - reduce : 콜백 함수의 반환 값들을 하나의 값(acc)에 누적 후 반환
      - 하나의 결과 값을 반환 (자주 쓸 것 같음)
    - find : 콜백 함수의 반환 값이 참이면 해당하는 첫번째 요소를 반환
    - some : 배열의 요소 중 하나라도 판별 함수를 통과하면 참을 반환
      - 빈 배열은 항상 false를 반환
    - every : 배열의 모든 요소가 판별 함수를 통과하면 참을 반환
      - 빈 배열은 항상 true를 반환

- 객체
  - 객체는 속성의 집합이며, 중괄호 내부에 key와 value의 쌍으로 표현
  - key는 문자열 타입만 가능
    - key 이름에 띄어쓰기 등의 구분자가 있으면 따옴표로 묶어서 표현
  - value는 모든 타입 가능
  - 객체 요소 접근은 점(.) 또는 대괄호([])로 가능
    - key 이름에 띄어쓰기 같은 구분자가 있으면 대괄호 접근만 가능
  - 속셩명 축약 key와 value가 같으면 하나만 사용해서 축약 가능(books: books === books)
  - 메서드 선언 시 function 키워드 생략 가능
  - 계산된 속성 : 객체를 정의할 때 key의 이름을 표현식을 이용하여 동적으로 생성 가능 (대괄호 사용)
  - 구조 분해 할당
  - Spread syntax(...) : 얕은 복사에 활용 가능
  - JSON
    - javascript object notation
    - key-value 형태로 이루어진 자료 표기법
    - javascript의 object와 유사한 구조를 가지고 있지만 object는 그 자체로 타입이고, JSON은 형식이 있는 "문자열"
    - 즉, JSON을 object로 사용하기 위해서는 변환 작업이 필요
      - JSON.stringify(jsondata) object -> json
      - JSON.parse(stringdata) json -> object



1
